"""
Register and configure the C `diagnostics()` driver for scheduled simulation diagnostics.

This module provides a single registration function, `register_CFunction_diagnostics`,
which constructs the top-level C `diagnostics()` function and registers the
`diagnostics_output_every` CodeParameter. The generated C driver:
  - Detects output steps from `time`, `dt`, and `diagnostics_output_every`.
  - Temporarily frees MoL work arrays prior to running diagnostics.
  - Allocates and populates `diagnostic_gfs` via `diagnostic_gfs_set(...)`.
  - Conditionally calls NRPy-generated routines (e.g., `diagnostics_interp()` and
    `diagnostics_volume_integrals()`), as enabled at codegen time.
  - Releases temporary storage and restores MoL work arrays afterward.
  - Advances the progress indicator each call and prints a newline when the run ends.

Users supply the default output cadence and choose which diagnostic families are
enabled when registering the function.

Functions
---------
register_CFunction_diagnostics
    Constructs and registers the C `diagnostics()` driver from code snippets and
    feature flags; also registers `diagnostics_output_every` as a commondata parameter.

Author: Zachariah B. Etienne
        zachetie **at** gmail **dot* com
"""

from inspect import currentframe as cfr
from types import FrameType as FT
from typing import Set, Union, cast

import nrpy.c_function as cfc
import nrpy.helpers.parallel_codegen as pcg
import nrpy.params as par
from nrpy.helpers.generic import copy_files
from nrpy.infrastructures import BHaH


def register_CFunction_diagnostics(
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
) -> Union[None, pcg.NRPyEnv_type]:
    """
    Register the top-level diagnostics() C function.

    :param default_diagnostics_out_every: Default value for the commondata parameter
        `diagnostics_output_every`, which controls the diagnostics output cadence.
    :param enable_interp_diagnostics: If True, the generated C driver calls
        diagnostics_interp(...) on output steps.
    :param enable_volume_integration_diagnostics: If True, the generated C driver calls
        diagnostics_volume_integrals(...) on output steps.

    :return: None if in registration phase (after recording the requested registration),
        else the updated NRPy environment object.
    """
    if pcg.pcg_registration_phase():
        pcg.register_func_call(f"{__name__}.{cast(FT, cfr()).f_code.co_name}", locals())
        return None

    # --- C Function Registration ---
    includes = [
        "BHaH_defines.h",
        "BHaH_function_prototypes.h",
        "diagnostics/diagnostic_gfs.h",
    ]
    desc = r"""
 * @brief Driver for all scheduled diagnostics.
 *
 * @details This routine is the top-level diagnostics driver generated by
 * BlackHoles@Home/NRPy. On each invocation it checks whether the current
 * simulation time falls on a diagnostics output step. If so, it:
 *   1) frees MoL temporary work arrays to make memory available,
 *   2) allocates per-grid temporary storage `diagnostic_gfs`,
 *   3) initializes that storage via `diagnostic_gfs_set(...)`,
 *   4) calls enabled diagnostics (e.g., `diagnostics_interp()` and/or
 *      `diagnostics_volume_integrals()`),
 *   5) frees `diagnostic_gfs`, and
 *   6) restores MoL work arrays so time-stepping can resume.
 * Regardless of whether an output step occurs, the function advances the
 * progress indicator every call, and prints a trailing newline when the run
 * is about to finish.
 *
 * Scheduling: An output step is detected when
 *   fabs(round(time / diagnostics_output_every) * diagnostics_output_every - time)
 *   < 0.5 * dt.
 *
 * @param[in,out] commondata  Global simulation metadata and run-time parameters
 * (e.g., `time`, `dt`, `diagnostics_output_every`, `t_final`, and `NUMGRIDS`).
 * @param[in,out] griddata    Per-grid data, including grid parameters, solution
 * fields, and any workspace used by diagnostics.
 *
 * @pre
 * - `commondata` and `griddata` are non-null and initialized.
 * - `commondata->NUMGRIDS >= 1`.
 * - Grid dimensions and backing arrays are valid.
 * - NRPy-generated diagnostics and related enums/indices are consistent with the
 *   build configuration.
 *
 * @post
 * - On an output step, all enabled diagnostics run and may perform I/O.
 * - On non-output steps, no diagnostic I/O is performed and the simulation state
 *   is unchanged.
 * - MoL work arrays are freed only for the duration of diagnostics and are
 *   subsequently restored.
 * - The progress indicator is advanced every call; a newline is printed if
 *   `time + dt > t_final`.
 *
 * @warning
 * - Failures in I/O or memory allocation within diagnostics are fatal and may
 *   abort the program.
 * - The set of enabled diagnostics is determined at code generation time; manual
 *   changes to interfaces must remain consistent with generated code.
 *
 * @return Void.
"""
    parallelization = par.parval_from_str("parallelization")
    _ = par.CodeParameter(
        "REAL",
        __name__,
        "diagnostics_output_every",
        default_diagnostics_out_every,
        commondata=True,
    )
    cfunc_type = "void"
    name = "diagnostics"
    params = (
        "commondata_struct *restrict commondata, griddata_struct *restrict griddata"
    )
    if parallelization == "cuda":
        params = "commondata_struct *restrict commondata, griddata_struct *restrict griddata_device, griddata_struct *restrict griddata"
    griddata_host = "griddata_host" if parallelization == "cuda" else "griddata"
    body = f"""
  const REAL currtime = commondata->time, currdt = commondata->dt, outevery = commondata->diagnostics_output_every;
  // Explanation of the if() below:
  // Step 1: round(currtime / outevery) rounds to the nearest integer multiple of currtime/outevery.
  // Step 2: Multiplying by outevery yields the exact time we should output again, t_out.
  // Step 3: If fabs(t_out - currtime) < 0.5 * currdt, then currtime is as close to t_out as possible!
  if (fabs(round(currtime / outevery) * outevery - currtime) < 0.5 * currdt) {{
    // Diagnostics require additional memory, so first free all scratch storage needed for MoL timestepping.
    // FIXME: will address this later. Make code work first, then optimize later.
    // for (int grid = 0; grid < commondata->NUMGRIDS; grid++)
    //   MoL_free_intermediate_stage_gfs(&griddata[grid].gridfuncs);

    // Allocate temporary storage for diagnostic_gfs.
    REAL *diagnostic_gfs[MAXNUMGRIDS];
    for (int grid = 0; grid < commondata->NUMGRIDS; grid++) {{
      SET_NXX_PLUS_2NGHOSTS_VARS(grid);
      const int Nxx_plus_2NGHOSTS_tot = Nxx_plus_2NGHOSTS0 * Nxx_plus_2NGHOSTS1 * Nxx_plus_2NGHOSTS2;
      BHAH_MALLOC(diagnostic_gfs[grid], TOTAL_NUM_DIAG_GFS * Nxx_plus_2NGHOSTS_tot * sizeof(REAL));

#ifdef __CUDACC__
      // This does not leverage async memory transfers using multiple streams at the moment
      // given the current intent is one cuda stream per grid. This could be leveraged
      // in the future by increasing NUM_STREAMS such that a diagnostic stream is included per grid
      const params_struct *restrict params = &griddata_device[grid].params;
      size_t streamid = params->grid_idx % NUM_STREAMS;
      cpyHosttoDevice_params__constant(&griddata_device[grid].params, streamid);
      // Copy solution to host
      for(int gf=0;gf<NUM_EVOL_GFS;gf++)
        cpyDevicetoHost__gf(commondata, params, griddata[grid].gridfuncs.y_n_gfs, griddata_device[grid].gridfuncs.y_n_gfs, gf,gf, streamid);
      // Sync data before attempting to write to file
      cudaStreamSynchronize(streams[streamid]);
#endif // __CUDACC__
    }} // END LOOP over grids

    // Set diagnostics_gfs -- see nrpy/infrastructures/BHaH/[project]/diagnostics/ for definition.
    diagnostic_gfs_set(commondata, griddata, diagnostic_gfs);

    {"// Nearest-point diagnostics, at center, along y,z axes (1D) and xy and yz planes (2D)." if enable_nearest_diagnostics else ""}
    {"diagnostics_nearest(commondata, griddata, (const double **)diagnostic_gfs);\n" if enable_nearest_diagnostics else ""}
    {"// Interpolation diagnostics, at center, along x,y,z axes (1D) and xy and yz planes (2D)." if enable_interp_diagnostics else ""}
    {"diagnostics_interp(commondata, griddata, (const double **)diagnostic_gfs);\n" if enable_interp_diagnostics else ""}
    {"// Volume-integration diagnostics." if enable_volume_integration_diagnostics else ""}
    {"diagnostics_volume_integration(commondata, griddata, (const double **)diagnostic_gfs);\n" if enable_volume_integration_diagnostics else ""}
    // Free temporary storage allocated to diagnostic_gfs.
    for(int grid=0; grid<commondata->NUMGRIDS; grid++)
      free(diagnostic_gfs[grid]);

    // Re-allocate all scratch storage needed for resumption of MoL timestepping.
    // FIXME: will address this later. Make code work first, then optimize later.
    // for (int grid = 0; grid < commondata->NUMGRIDS; grid++)
    //   MoL_malloc_intermediate_stage_gfs(commondata, &griddata[grid].params, &griddata[grid].gridfuncs);
  }} // END if output step

  progress_indicator(commondata, griddata);
  if (commondata->time + commondata->dt > commondata->t_final) printf("\\n");
"""
    cfc.register_CFunction(
        subdirectory="diagnostics",
        includes=includes,
        desc=desc,
        cfunc_type=cfunc_type,
        name=name,
        params=params,
        include_CodeParameters_h=False,
        body=body,
    )
    return pcg.NRPyEnv()


def register_all_diagnostics(
    project_dir: str,
    set_of_CoordSystems: Set[str],
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
):
    filenames_list_to_copy = []
    if enable_nearest_diagnostics:
        filenames_list_to_copy += ["diagnostics_nearest_common.h"]
    if enable_volume_integration_diagnostics:
        filenames_list_to_copy += ["diagnostics_volume_integration_helpers.h"]
    if filenames_list_to_copy:
        copy_files(
            package="nrpy.infrastructures.BHaH.diagnostics",
            filenames_list=filenames_list_to_copy,
            project_dir=project_dir,
            subdirectory="diagnostics",
        )

    register_CFunction_diagnostics(
        default_diagnostics_out_every=default_diagnostics_out_every,
        enable_nearest_diagnostics=enable_nearest_diagnostics,
        enable_interp_diagnostics=enable_interp_diagnostics,
        enable_volume_integration_diagnostics=enable_volume_integration_diagnostics,
        enable_free_auxevol=enable_free_auxevol,
    )
    if enable_nearest_diagnostics:
        for CoordSystem in set_of_CoordSystems:
            BHaH.diagnostics.diagnostics_nearest_grid_center.register_CFunction_diagnostics_nearest_grid_center(
                CoordSystem=CoordSystem
            )
            BHaH.diagnostics.diagnostics_nearest_1d_y_and_z_axes.register_CFunction_diagnostics_nearest_1d_y_and_z_axes(
                CoordSystem=CoordSystem
            )
            BHaH.diagnostics.diagnostics_nearest_2d_xy_and_yz_planes.register_CFunction_diagnostics_nearest_2d_xy_and_yz_planes(
                CoordSystem=CoordSystem
            )
    if enable_volume_integration_diagnostics:
        for CoordSystem in set_of_CoordSystems:
            BHaH.diagnostics.sqrt_detgammahat_d3xx_volume_element.register_CFunction_sqrt_detgammahat_d3xx_volume_element(
                CoordSystem=CoordSystem
            )


if __name__ == "__main__":
    import doctest
    import sys

    results = doctest.testmod()

    if results.failed > 0:
        print(f"Doctest failed: {results.failed} of {results.attempted} test(s)")
        sys.exit(1)
    else:
        print(f"Doctest passed: All {results.attempted} test(s) passed")
